CREATE DATABASE  IF NOT EXISTS `ideal_java_engineer` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `ideal_java_engineer`;
-- MySQL dump 10.13  Distrib 8.0.36, for Win64 (x86_64)
--
-- Host: localhost    Database: ideal_java_engineer
-- ------------------------------------------------------
-- Server version	8.0.36

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `blog_post`
--

DROP TABLE IF EXISTS `blog_post`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_post` (
  `author_id` bigint DEFAULT NULL,
  `blog_id` bigint NOT NULL AUTO_INCREMENT,
  `category_id` bigint DEFAULT NULL,
  `created_at` datetime(6) DEFAULT NULL,
  `last_updated_at` datetime(6) DEFAULT NULL,
  `published_at` datetime(6) DEFAULT NULL,
  `blog_name` varchar(255) DEFAULT NULL,
  `content` text,
  `likes` int DEFAULT NULL,
  `dislikes` int DEFAULT NULL,
  `image_url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`blog_id`),
  KEY `FKr9jb17wqqs4slx1m817x1u49n` (`author_id`),
  KEY `FKpdvgg16k03cv8mk8pnd7lp68u` (`category_id`),
  CONSTRAINT `FKpdvgg16k03cv8mk8pnd7lp68u` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`),
  CONSTRAINT `FKr9jb17wqqs4slx1m817x1u49n` FOREIGN KEY (`author_id`) REFERENCES `author` (`author_id`)
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_post`
--

LOCK TABLES `blog_post` WRITE;
/*!40000 ALTER TABLE `blog_post` DISABLE KEYS */;
INSERT INTO `blog_post` VALUES (1,1,2,'2024-02-29 21:18:38.350000',NULL,'2024-02-29 21:18:38.350000','3 Understanding object/relational persistence','<h1><strong>object/relational persistence</strong></h1><p></p><p style=\"text-align: justify\">Understanding</p><p style=\"text-align: justify\">object/relational persistence</p><p style=\"text-align: justify\">This book is about Hibernate; our focus is on using Hibernate as a provider of the</p><p style=\"text-align: justify\">Java Persistence API. We cover basic and advanced features and describe some ways</p><p style=\"text-align: justify\">to develop new applications using Java Persistence. Often, these recommendations</p><p style=\"text-align: justify\">aren’t specific to Hibernate. Sometimes they’re our own ideas about the best ways to</p><p style=\"text-align: justify\">do things when working with persistent data, explained in the context of Hibernate.</p><p style=\"text-align: justify\">The approach to managing persistent data has been a key design decision in</p><p style=\"text-align: justify\">every software project we’ve worked on. Given that persistent data isn’t a new or</p><p style=\"text-align: justify\">unusual requirement for Java applications, you’d expect to be able to make a simple</p><p style=\"text-align: justify\">choice among similar, well-established persistence solutions. Think of web applica-</p><p style=\"text-align: justify\">tion frameworks (JavaServer Faces versus Struts versus GWT), GUI component</p>',14,3,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,2,2,'2024-02-29 23:12:52.385000',NULL,'2024-02-29 23:12:52.385000','3 Understanding object/relational persistence','<h1><strong>object/relational persistence</strong></h1><p></p><p style=\"text-align: justify\">Understanding</p><p style=\"text-align: justify\">object/relational persistence</p><p style=\"text-align: justify\">This book is about Hibernate; our focus is on using Hibernate as a provider of the</p><p style=\"text-align: justify\">Java Persistence API. We cover basic and advanced features and describe some ways</p><p style=\"text-align: justify\">to develop new applications using Java Persistence. Often, these recommendations</p><p style=\"text-align: justify\">aren’t specific to Hibernate. Sometimes they’re our own ideas about the best ways to</p><p style=\"text-align: justify\">do things when working with persistent data, explained in the context of Hibernate.</p><p style=\"text-align: justify\">The approach to managing persistent data has been a key design decision in</p><p style=\"text-align: justify\">every software project we’ve worked on. Given that persistent data isn’t a new or</p><p style=\"text-align: justify\">unusual requirement for Java applications, you’d expect to be able to make a simple</p><p style=\"text-align: justify\">choice among similar, well-established persistence solutions. Think of web applica-</p><p style=\"text-align: justify\">tion frameworks (JavaServer Faces versus Struts versus GWT), GUI componentframeworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p style=\"text-align: justify\">the competing solutions has various advantages and disadvantages, but they all share</p><p style=\"text-align: justify\">the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p style=\"text-align: justify\">tence technologies, where we see some wildly differing solutions to the same problem.</p><p style=\"text-align: justify\">Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p style=\"text-align: justify\">tence a problem that is already solved by SQL and extensions such as stored proce-</p><p style=\"text-align: justify\">dures, or is it a more pervasive problem that must be addressed by special Java</p><p style=\"text-align: justify\">component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p style=\"text-align: justify\">(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p style=\"text-align: justify\">automated? How do we achieve portability if every database management system has</p><p style=\"text-align: justify\">its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p style=\"text-align: justify\">base technology, such as object database systems or NoSQL systems? The debate may</p><p style=\"text-align: justify\">never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p style=\"text-align: justify\">tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p style=\"text-align: justify\">vice implementation.</p>',101,2,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,3,2,'2024-03-01 00:22:22.008000',NULL,'2024-03-01 00:22:22.008000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,4,2,'2024-03-01 00:22:26.508000',NULL,'2024-03-01 00:22:26.508000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,5,2,'2024-03-01 00:22:29.117000',NULL,'2024-03-01 00:22:29.117000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,6,2,'2024-03-01 00:22:31.582000',NULL,'2024-03-01 00:22:31.582000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,11,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,7,2,'2024-03-01 00:22:33.959000',NULL,'2024-03-01 00:22:33.959000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,8,2,'2024-03-01 00:22:36.978000',NULL,'2024-03-01 00:22:36.978000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,11,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,9,2,'2024-03-01 00:22:40.681000',NULL,'2024-03-01 00:22:40.681000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,10,2,'2024-03-01 00:22:41.089000',NULL,'2024-03-01 00:22:41.089000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,11,2,'2024-03-01 00:22:41.274000',NULL,'2024-03-01 00:22:41.274000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,12,2,'2024-03-01 00:22:41.439000',NULL,'2024-03-01 00:22:41.439000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,11,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,13,2,'2024-03-01 00:22:41.589000',NULL,'2024-03-01 00:22:41.589000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,14,2,'2024-03-01 00:22:41.757000',NULL,'2024-03-01 00:22:41.757000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,15,2,'2024-03-01 00:22:41.914000',NULL,'2024-03-01 00:22:41.914000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,16,2,'2024-03-01 00:22:42.058000',NULL,'2024-03-01 00:22:42.058000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,17,2,'2024-03-01 00:22:42.278000',NULL,'2024-03-01 00:22:42.278000','Framework: 1','<h2><strong>Framework: 1</strong></h2><p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p>',1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,18,2,'2024-03-04 11:52:26.640000',NULL,'2024-03-04 11:52:26.640000','Testing jpa BLog','<p style=\"text-align: justify\">frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p style=\"text-align: justify\">the competing solutions has various advantages and disadvantages, but they all share</p><p style=\"text-align: justify\">the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p style=\"text-align: justify\">tence technologies, where we see some wildly differing solutions to the same problem.</p><p style=\"text-align: justify\">Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p style=\"text-align: justify\">tence a problem that is already solved by SQL and extensions such as stored proce-</p><p style=\"text-align: justify\">dures, or is it a more pervasive problem that must be addressed by special Java</p><p style=\"text-align: justify\">component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p style=\"text-align: justify\">(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p style=\"text-align: justify\">automated? How do we achieve portability if every database management system has</p><p style=\"text-align: justify\">its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p style=\"text-align: justify\">base technology, such as object database systems or NoSQL systems? The debate may</p><p style=\"text-align: justify\">never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p style=\"text-align: justify\">tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p style=\"text-align: justify\">vice implementation.</p><img src=\"https://images.unsplash.com/photo-1589149098258-3e9102cd63d3?q=80&amp;w=2539&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"><p></p><pre><code>import React from \'react\';\nimport { useHistory } from \'react-router-dom\';\n\nconst MyComponent = () =&gt; {\n  const history = useHistory();\n\n  const handleClick = (route) =&gt; {\n    history.push(route);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;My Component&lt;/h1&gt;\n      &lt;button onClick={() =&gt; handleClick(\'/page1\')}&gt;Go to Page 1&lt;/button&gt;\n      &lt;button onClick={() =&gt; handleClick(\'/page2\')}&gt;Go to Page 2&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;</code></pre><p></p>',19,6,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,19,4,'2024-03-24 02:38:19.555000',NULL,'2024-03-24 02:38:19.555000','Testing Journal','<p>frameworks (Swing versus SWT), or template engines ( JSP versus Thymeleaf). Each of</p><p>the competing solutions has various advantages and disadvantages, but they all share</p><p>the same scope and overall approach. Unfortunately, this isn’t yet the case with persis-</p><p>tence technologies, where we see some wildly differing solutions to the same problem.</p><p>Persistence has always been a hot topic of debate in the Java community. Is persis-</p><p>tence a problem that is already solved by SQL and extensions such as stored proce-</p><p>dures, or is it a more pervasive problem that must be addressed by special Java</p><p>component models, such as EJBs? Should we hand-code even the most primitive CRUD</p><p>(create, read, update, delete) operations in SQL and JDBC, or should this work be</p><p>automated? How do we achieve portability if every database management system has</p><p>its own SQL dialect? Should we abandon SQL completely and adopt a different data-</p><p>base technology, such as object database systems or NoSQL systems? The debate may</p><p>never end, but a solution called object/relational mapping ( ORM ) now has wide accep-</p><p>tance, thanks in large part to the innovations of Hibernate, an open source ORM ser-</p><p>vice implementation.</p><p>Before we can get started with Hibernate, you need to understand the core prob-</p><p>lems of object persistence and ORM. This chapter explains why you need tools like</p><p>Hibernate and specifications such as the Java Persistence API (JPA).</p><p>First we define persistent data management in the context of object-oriented appli-</p><p>cations and discuss the relationship of SQL , JDBC, and Java, the underlying technolo-</p><p>gies and standards that Hibernate builds on. We then discuss the so-called</p><p>object/relational paradigm mismatch and the generic problems we encounter in object-</p><p>oriented software development with SQL databases. These problems make it clear that</p><p>we need tools and patterns to minimize the time we have to spend on the persistence-</p><p>related code in our applications.</p><p>The best way to learn Hibernate isn’t necessarily linear. We understand that you</p><p>may want to try Hibernate right away. If this is how you’d like to proceed, skip to the</p><p>next chapter and set up a project with the “Hello World” example. We recommend</p><p>that you return here at some point as you go through this book; that way, you’ll be pre-</p><p>pared and have all the background concepts you need for the rest of the material.</p><p>1.1 What is persistence?</p><p>Almost all applications require persistent data. Persistence is one of the fundamental</p><p>concepts in application development. If an information system didn’t preserve data</p><p>when it was powered off, the system would be of little practical use. Object persistence</p><p>means individual objects can outlive the application process; they can be saved to a</p><p>data store and be re-created at a later point in time. When we talk about persistence in</p><p>Java, we’re normally talking about mapping and storing object instances in a database</p><p>using SQL . We start by taking a brief look at the technology and how it’s used in Java.</p><p>Armed with this information, we then continue our discussion of persistence and how</p><p>it’s implemented in object-oriented applications.</p><p></p>',2,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,20,3,'2024-03-24 02:57:26.296000',NULL,'2024-03-24 02:57:26.296000','Testing Review Blog','<p>5What is persistence?</p><p>1.1.1 Relational databases</p><p>You, like most other software engineers, have probably worked with SQL and rela-</p><p>tional databases; many of us handle such systems every day. Relational database man-</p><p>agement systems have SQL-based application programming interfaces; hence, we call</p><p>today’s relational database products SQL database management systems (DBMS ) or, when</p><p>we’re talking about particular systems, SQL databases.</p><p>Relational technology is a known quantity, and this alone is sufficient reason for</p><p>many organizations to choose it. But to say only this is to pay less respect than is due.</p><p>Relational databases are entrenched because they’re an incredibly flexible and robust</p><p>approach to data management. Due to the well-researched theoretical foundation of</p><p>the relational data model, relational databases can guarantee and protect the integrity</p><p>of the stored data, among other desirable characteristics. You may be familiar with E.F.</p><p>Codd’s four-decades-old introduction of the relational model, A Relational Model of</p><p>Data for Large Shared Data Banks (Codd, 1970). A more recent compendium worth</p><p>reading, with a focus on SQL, is C. J. Date’s SQL and Relational Theory (Date, 2009).</p><p>Relational DBMSs aren’t specific to Java, nor is an SQL database specific to a partic-</p><p>ular application. This important principle is known as data independence. In other</p><p>words, and we can’t stress this important fact enough, data lives longer than any applica-</p><p>tion does. Relational technology provides a way of sharing data among different appli-</p><p>cations, or among different parts of the same overall system (the data entry</p><p>application and the reporting application, for example). Relational technology is a</p><p>common denominator of many disparate systems and technology platforms. Hence,</p><p>the relational data model is often the foundation for the common enterprise-wide</p><p>representation of business entities.</p><p>Before we go into more detail about the practical aspects of SQL databases, we</p><p>have to mention an important issue: although marketed as relational, a database sys-</p><p>tem providing only an SQL data language interface isn’t really relational and in many</p><p>ways isn’t even close to the original concept. Naturally, this has led to confusion. SQL</p><p>practitioners blame the relational data model for shortcomings in the SQL language,</p><p>and relational data management experts blame the SQL standard for being a weak</p><p>implementation of the relational model and ideals. Application engineers are stuck</p><p>somewhere in the middle, with the burden of delivering something that works. We</p><p>highlight some important and significant aspects of this issue throughout this book,</p><p>but generally we focus on the practical aspects. If you’re interested in more back-</p><p>ground material, we highly recommend Practical Issues in Database Management: A Refer-</p><p>ence for the Thinking Practitioner by Fabian Pascal (Pascal, 2000) and An Introduction to</p><p>Database Systems by Chris Date (Date, 2003) for the theory, concepts, and ideals of</p><p>(relational) database systems. The latter book is an excellent reference (it’s big) for all</p><p>questions you may possibly have about databases and data management.</p>',2,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,21,NULL,NULL,NULL,NULL,NULL,NULL,1,11,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,22,NULL,NULL,NULL,NULL,NULL,NULL,1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,23,NULL,NULL,NULL,NULL,NULL,NULL,1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,24,NULL,NULL,NULL,NULL,NULL,NULL,1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,25,NULL,NULL,NULL,NULL,NULL,NULL,1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,26,NULL,NULL,NULL,NULL,NULL,NULL,1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(NULL,27,NULL,NULL,NULL,NULL,NULL,NULL,1,1,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,28,3,'2024-03-27 23:56:21.227000',NULL,'2024-03-27 23:56:21.227000','testing blog - 2','<h2>test it now</h2><p>ok let se what we can do if it move to next line does it be a part of a same paragraph or sifted to the next one that really important for us to check right now let se with that example what gonna do and add some useless words.</p>',1,0,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,29,3,'2024-03-27 23:59:31.928000',NULL,'2024-03-27 23:59:31.928000','testing blog - 3','<h2>test it now</h2><p style=\"text-align: justify\">ok let se what we can do if it move to next line does it be a part of a same paragraph or sifted to the next one that really important for us to check right now let se with that example what gonna do and add some useless words.</p>',0,0,'https://drive.google.com/uc?export=view&id=1MPCzkMfmLrUy93yAUWwba3GktfsZFNin'),(1,30,4,'2024-03-29 01:04:57.103000',NULL,'2024-03-29 01:04:57.103000','testing if image is stored properly','<p>let start sdlkfjsalkfjsl;kdfa</p><p>sf \'sdfsdkfjskdlfjslkdfjlsd lksdj flksdlskd flksd flskd sldk skld lsd lksd ls sd jsldk s sdkl fsl dfs dfslkd fjsl fkj slkdfjslkd fslkd flskd lksd flksdjflksd fls dfkls dflksd fjlskd flskd fklsd flskd fslkdf slkjlwjroiwe riowue riowu eriow eurowi erpwuroidsjf lksdfj elpwqposkl djsklf sdpofie tjwlkhrklfjsl kdjf skl pof sdifuoiuwe prwjkrhw erwlkrjq lkjdf osfsidfoeiutkjwf lksdfjwl jerlkqwjr lksdjf speirow itwlk wjflksdjfoisdjfsoi dfs</p><p></p><p>d</p><p>fs</p><p>df</p><p>sd</p><p>f</p><p>sd</p><p>fs</p><p>d</p><p>fs</p><p>f</p><p>ds</p>',0,0,'https://drive.google.com/uc?export=view&id=1t-1p97-2Y-IgBCTe88t5bujOuYfavBgR'),(1,31,4,'2024-03-29 01:14:22.335000',NULL,'2024-03-29 01:14:22.335000','testing for header image show','<p>sdfs </p><p> s</p><p>d </p><p>sd</p><p> f</p><p>sd</p><p> f</p><p>sd</p><p> s</p><p>s</p><p>dfsdfsdfsd</p><p> sdf </p><p>sd</p><p> s</p><p>df </p>',0,0,'https://plus.unsplash.com/premium_photo-1711508491465-1f242f42c826?w=700&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwyfHx8ZW58MHx8fHx8');
/*!40000 ALTER TABLE `blog_post` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-03-30 15:43:00
